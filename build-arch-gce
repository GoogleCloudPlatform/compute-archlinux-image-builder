#!/bin/bash
# Copyright 2018 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -eEuo pipefail
trap 'echo "Error: \`$BASH_COMMAND\` exited with status $?"' ERR

if (( EUID != 0 )); then
	echo 'This script must be run with root privileges.'
	exit 1
fi

# Setup cleanup trap to remove all temporary data.
cleanup() {
	echo '- Cleaning up.'
	[[ ${mount_dir:-} ]] && umount --recursive -- "$mount_dir"
	[[ ${loop_dev:-} ]] && losetup --detach "$loop_dev"
	[[ ${work_dir:-} ]] && rm -r -- "$work_dir"
	return 0
}
trap cleanup EXIT

echo '- Creating an empty raw disk image.'
work_dir=$(mktemp --directory --tmpdir="$PWD" build-arch-gce.XXX)
disk_raw=$work_dir/disk.raw
truncate --size=10G -- "$disk_raw"

echo '- Setting up a loop device and partitioning the image.'
loop_dev=$(losetup --find --partscan --show -- "$disk_raw")
sfdisk --quiet -- "$loop_dev" <<-'EOF'
	label:gpt
	type=C12A7328-F81F-11D2-BA4B-00A0C93EC93B,size=300MiB,name=efi
	type=4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709,name=root
EOF

echo '- Formatting the root partition.'
root_dev=${loop_dev}p2
mkfs.ext4 -q -L root -- "$root_dev"
tune2fs -c 0 -i 0 -- "$root_dev"

echo '- Formatting the EFI partition.'
efi_dev=${loop_dev}p1
mkfs.vfat -F32 -n EFI -- "$efi_dev"

echo '- Mounting the root partition.'
mount_dir=$work_dir/disk.mnt
mkdir -- "$mount_dir"
mount -- "$root_dev" "$mount_dir"

echo '- Mounting the EFI partition.'
mkdir -- "$mount_dir/efi"
mkdir -- "$mount_dir/boot"
mount -- "$efi_dev" "$mount_dir/efi"
mount --bind -- "$mount_dir/efi" $mount_dir/boot

echo '- Installing Arch Linux.'
append_gce_repo() {
	gawk -i inplace '
		/^\[gce\]$/ { found = 1 } { print }
		ENDFILE { if (!found) {
			print ""
			print "[gce]"
			print "Server = https://storage.googleapis.com/arch-linux-gce/repo"
			print "SigLevel = Optional TrustAll"
		} }' "$1"
}
cp /etc/pacman.conf "$work_dir"
append_gce_repo "$work_dir/pacman.conf"
pacstrap -G -M -C "$work_dir/pacman.conf" -- "$mount_dir" \
	base linux dosfstools e2fsprogs dhclient openssh sudo google-compute-engine growpartfs
append_gce_repo "$mount_dir/etc/pacman.conf"

echo '- Configuring fstab.'
cp -f -- ./sys/etc/fstab $mount_dir/etc/fstab

echo '- Running additional setup in chroot.'
arch-chroot -- "$mount_dir" /bin/bash -s <<-'EOS'
	set -eEuo pipefail
	trap 'echo "Error: \`$BASH_COMMAND\` exited with status $?"' ERR

	echo '-- Configuring time.'
	ln -sf /usr/share/zoneinfo/UTC /etc/localtime
	gawk -i assert -i inplace '
		/^#NTP=/ { $0 = "NTP=metadata.google.internal"; ++f }
		{ print } END { assert(f == 1, "f == 1") }' /etc/systemd/timesyncd.conf
	systemctl --quiet enable systemd-timesyncd.service

	echo '-- Configuring locale.'
	gawk -i assert -i inplace '
		/^#en_US\.UTF-8 UTF-8\s*$/ { $0 = substr($0, 2); ++f }
		{ print } END { assert(f == 1, "f == 1") }' /etc/locale.gen
	locale-gen
	echo 'LANG=en_US.UTF-8' > /etc/locale.conf

	echo '-- Configuring journald.'
	gawk -i assert -i inplace '
		/^#ForwardToConsole=/ { $0 = "ForwardToConsole=yes"; ++f }
		{ print } END { assert(f == 1, "f == 1") }' /etc/systemd/journald.conf

	echo '-- Configuring ssh.'
	gawk -i assert -i inplace '
		/^#PasswordAuthentication / { $0 = "PasswordAuthentication no"; ++f1 }
		/^#PermitRootLogin / { $0 = "PermitRootLogin no"; ++f2 }
		{ print } END { assert(f1 * f2 == 1, "f == 1") }' /etc/ssh/sshd_config
	systemctl --quiet enable sshd.service

	echo '-- Configuring pacman.'
	curl --silent --show-error -o /etc/pacman.d/mirrorlist \
		'https://archlinux.org/mirrorlist/?country=all&ip_version=4&use_mirror_status=on'
	gawk -i assert -i inplace '
		/^#Server / { $0 = substr($0, 2); ++f }
		{ print } END { assert(f > 0, "f > 0") }' /etc/pacman.d/mirrorlist
	cat <<-'EOF' > /etc/systemd/system/pacman-init.service
		[Unit]
		Description=Pacman keyring initialization
		ConditionDirectoryNotEmpty=!/etc/pacman.d/gnupg

		[Service]
		Type=oneshot
		RemainAfterExit=yes
		ExecStart=/usr/bin/pacman-key --init
		ExecStart=/usr/bin/pacman-key --populate archlinux

		[Install]
		WantedBy=multi-user.target
	EOF
	systemctl --quiet enable pacman-init.service

	echo '-- Enabling other services.'
	systemctl --quiet enable dhclient@eth0.service growpartfs@-.service

	echo '-- Configuring initcpio.'
	gawk -i assert -i inplace '
		/^MODULES=/ { $0 = "MODULES=(virtio_pci virtio_scsi sd_mod ext4)"; ++f1 }
		/^BINARIES=/ { $0 = "BINARIES=(fsck fsck.ext4)"; ++f2 }
		/^HOOKS=/ { $0 = "HOOKS=(base systemd autodetect modconf block filesystems fsck)"; ++f3 }
		{ print } END { assert(f1 * f2 * f3 == 1, "f == 1") }' /etc/mkinitcpio.conf
	gawk -i assert -i inplace '
		/^PRESETS=/ { $0 = "PRESETS=(default)"; ++f }
		/#?fallback_/ { next }
		{ print } END { assert(f == 1, "f == 1") }' /etc/mkinitcpio.d/linux.preset
	rm /boot/initramfs-linux-fallback.img
	mkinitcpio --nocolor --preset linux

	echo '-- Running boot loader.'
	bootctl install
EOS

echo '- Configuring boot loader.'
cp -f -- ./sys/efi/loader/loader.conf $mount_dir/efi/loader/
cp -f -- ./sys/efi/loader/entries/arch.conf $mount_dir/efi/loader/entries/

echo '- Configuring pacman hooks.'
mkdir -p -- "$mount_dir/etc/pacman.d/hooks"
cp -f -- ./sys/etc/pacman.d/hooks/00-systemd-boot.hook $mount_dir/etc/pacman.d/hooks/

echo '- Cleaning up and finalizing the image.'
> "$mount_dir/etc/machine-id"
rm -- "$mount_dir/var/log/pacman.log"
umount --recursive -- "$mount_dir"
unset mount_dir

echo '- Building the compressed image.'
disk_tar="arch-v$(date --utc +%Y%m%d).tar.gz"
tar --sparse -czf "$work_dir/$disk_tar" --directory="$work_dir" disk.raw
mv -- "$work_dir/$disk_tar" .

echo "Successfully built image \`$disk_tar\`."
